namespace zprol.lang.memory;

using zprol.lang.linux.amd64;
using zprol.lang;

class _BinElement {
    ubyte binType;
}

class _QuickBinElement {
    ubyte binType;
    _QuickBinElement next;
    _QuickBinElement prev;
    bool nextBlockFree;
}

class _mmapedBinElement {
    ubyte binType;
    uint64 length;
    uint64 mmapedLength;
}

_QuickBinElement quickBin;

bool shouldCheckNextBlock(_QuickBinElement current) {
    if(current.nextBlockFree) {
        return false;
    }
    return current.next != null;
}

byte[] malloc(ulong length) {
    if(length <= 64) {
        if(quickBin == null) {
            quickBin = (_QuickBinElement!) mmap_alloc(16 * 4096);
            quickBin.nextBlockFree = true;
        }
        _QuickBinElement prevElement = quickBin;
        while(shouldCheckNextBlock(prevElement)) {
            prevElement = prevElement.next;
        }
        _QuickBinElement thisElement = (_QuickBinElement!) ((uint64!) prevElement + 64 + 32);
        thisElement.binType = 0;
        thisElement.nextBlockFree = true;
        prevElement.nextBlockFree = false;
        if(prevElement.next != null) {
            thisElement.next = prevElement.next;
            prevElement.next.prev = thisElement;
        }
        prevElement.next = thisElement;
        thisElement.prev = prevElement;
        return (byte[]!) ((uint64!) thisElement + 32);
    }else => if(length >= 16384) {
        uint64 mmapedLength = (length + 16383 + 32) & 0xFFFFFFFFFFFFC000;
        _mmapedBinElement thisElement = (_mmapedBinElement!) mmap_alloc(mmapedLength);
        thisElement.binType = 1;
        thisElement.length = length;
        thisElement.mmapedLength = mmapedLength;
        return (byte[]!) ((uint64!) thisElement + 32);
    }else {
        return null;
    }
    return null;
}

void free(byte[] location) {
    _BinElement element = (_BinElement!) ((uint64!) location - 32);
    if(element.binType == 0) {
        _QuickBinElement qElement = (_QuickBinElement!) element;
        if(qElement.prev != null) {
            qElement.prev.next = qElement.next;
            qElement.prev.nextBlockFree = true;
        }
        if(qElement.next != null) {
            qElement.next.prev = qElement.prev;
        }
    }else => if(element.binType == 1) {
        _mmapedBinElement mElement = (_mmapedBinElement!) element;
        munmap((uint64!) mElement, mElement.mmapedLength);
    }
}

byte[] mmap_alloc(uint64 length) => return mmap(0, length, PROT_READ() | PROT_WRITE(), MAP_PRIVATE() | MAP_ANONYMOUS(), 0, 0);

byte[] mmap(uint64 addr, uint64 length, uint64 protection, uint64 flags, uint64 fd, uint64 offset) => 
    return (byte[]!) syscall(SYSCALL_MMAP(), addr, length, protection, flags, fd, offset);

void munmap(uint64 addr, uint64 length) => syscall(SYSCALL_MUNMAP(), addr, length);

int64 PROT_READ() => return 1;
int64 PROT_WRITE() => return 2;

int64 MAP_PRIVATE() => return 2;
int64 MAP_SHARED() => return 4;
int64 MAP_ANONYMOUS() => return 32;