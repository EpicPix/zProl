namespace zprol.compiler.lexer;

using zprol.compiler.lexer.utils;
using zprol.lang.linux.amd64;
using zprol.lang.memory;
using zprol.lang.io;
using zprol.lang;

int lex_test(String file) {
    int fd = file_open(file, O_RDONLY, 0);
    if(fd < 0) {
        return 1;
    }
    long length = file_length(fd);

    byte[] contents = malloc(length);
    file_read(fd, contents, length);
    file_close(fd);

    // no utf8 support, iterating byte by byte
    ulong index = 0;
    while(index < length) {
        ulong start = index;
        if(is_alphabet_or_underscore(contents[index])) {
            index = index + 1;
            while(index < length) {
                if(is_alphanumeric_or_underscore(contents[index]) == false) {
                    break;
                }
                index = index + 1;
            }
//            byte[] byteLoc = (byte[]!) ((ulong!) contents + start);
//            stdout("Word: ");
//            write(STDOUT, byteLoc, index-start);
//            stdout("\n");
            continue;
        }else {
            if(contents[index] == 0x30) {
                if(index + 1 < length) {
                    if((contents[index + 1] | 0x20) == 0x78) {
                        index = index + 2;
                        bool validHex = true;
                        while(index < length) {
                            if(is_alphanumeric_or_underscore(contents[index]) == false) {
                                break;
                            }
                            if(is_hexadecimal(contents[index]) == false) {
                                validHex = false;
                            }
                            index = index + 1;
                        }
//                        byte[] byteLoc = (byte[]!) ((ulong!) contents + start);
//                        stdout("Hex: ");
//                        if(validHex == false) {
//                            stdout("[invalid] ");
//                        }
//                        write(STDOUT, byteLoc, index-start);
//                        stdout("\n");
                    }else {
                        index = index + 1;
                        bool validNum = true;
                        while(index < length) {
                            if(is_alphanumeric_or_underscore(contents[index]) == false) {
                                break;
                            }
                            if(is_octal(contents[index]) == false) {
                                validNum = false;
                            }
                            index = index + 1;
                        }
//                        byte[] byteLoc = (byte[]!) ((ulong!) contents + start);
//                        if(index - start == 1) {
//                            stdout("Zero: ");
//                        }else {
//                            stdout("Octal: ");
//                            if(validNum == false) {
//                                stdout("[invalid] ");
//                            }
//                        }
//                        write(STDOUT, byteLoc, index-start);
//                        stdout("\n");
                    }
                }
                continue;
            }else => if(is_digit(contents[index])) {
                index = index + 1;
                bool validNum = true;
                while(index < length) {
                    if(is_alphanumeric_or_underscore(contents[index]) == false) {
                        break;
                    }
                    if(is_digit(contents[index]) == false) {
                        validNum = false;
                    }
                    index = index + 1;
                }
//                byte[] byteLoc = (byte[]!) ((ulong!) contents + start);
//                stdout("Decimal: ");
//                if(validNum == false) {
//                    stdout("[invalid] ");
//                }
//                write(STDOUT, byteLoc, index-start);
//                stdout("\n");
                continue;
            }else => if(contents[index] == 0x22) {
                index = index + 1;
                ulong strValueLen = 0;
                ulong startStr = index;
                while(index < length) {
                    if(contents[index] == 0x22) {
                        index = index + 1;
                        break;
                    }else => if(contents[index] == 0x5C) {
                        if(index + 1 > length) {
                            stdout("invalid: backslash eof\n");
                        }
                        index = index + 1;
                        byte next = contents[index];
                        if(is_newline(next)) {
                            stdout("invalid: new line in string after backslash\n");
                        }else => if(is_valid_escape_character(next)) {
                            strValueLen = strValueLen + 1;
                        }else {
                            stdout("invalid: bad escape sequence\n");
                        }
                        continue;
                    }else => if(is_newline(contents[index])) {
                        stdout("invalid: new line in string\n");
                    }
                    strValueLen = strValueLen + 1;
                    index = index + 1;
                }
                index = startStr;
                String str = (String!) malloc(16 + strValueLen);
                str.length = strValueLen;
                str.bytes = (byte[]!) ((long!) str + 16);
                ulong strIndex = 0;
                while(index < length) {
                    if(contents[index] == 0x22) {
                        index = index + 1;
                        break;
                    }else => if(contents[index] == 0x5C) {
                        if(index + 1 > length) {
                            stdout("invalid: backslash eof\n");
                        }
                        index = index + 1;
                        byte next = contents[index];
                        if(is_newline(next)) {
                            stdout("invalid: new line in string after backslash\n");
                        }else => if(is_valid_escape_character(next)) {
                            index = index + 1;
                            if(next == 0x5C) {
                                str.bytes[strIndex] = 0x5C;
                                strIndex = strIndex + 1;
                            }
                            if(next == 0x6E) {
                                str.bytes[strIndex] = 0x0A;
                                strIndex = strIndex + 1;
                            }
                            if(next == 0x72) {
                                str.bytes[strIndex] = 0x0D;
                                strIndex = strIndex + 1;
                            }
                            if(next == 0x66) {
                                str.bytes[strIndex] = 0x0C;
                                strIndex = strIndex + 1;
                            }
                            if(next == 0x27) {
                                str.bytes[strIndex] = 0x27;
                                strIndex = strIndex + 1;
                            }
                            if(next == 0x74) {
                                str.bytes[strIndex] = 0x09;
                                strIndex = strIndex + 1;
                            }
                            if(next == 0x62) {
                                str.bytes[strIndex] = 0x08;
                                strIndex = strIndex + 1;
                            }
                            if(next == 0x30) {
                                str.bytes[strIndex] = 0x00;
                                strIndex = strIndex + 1;
                            }
                            if(next == 0x22) {
                                str.bytes[strIndex] = 0x22;
                                strIndex = strIndex + 1;
                            }
                        }else {
                            stdout("invalid: bad escape sequence\n");
                        }
                        continue;
                    }else => if(is_newline(contents[index])) {
                        stdout("invalid: new line in string\n");
                    }
                    str.bytes[strIndex] = contents[index];
                    index = index + 1;
                    strIndex = strIndex + 1;
                }
//                byte[] byteLoc = (byte[]!) ((ulong!) contents + start);
//                stdout("String: ");
//                write(STDOUT, byteLoc, index-start);
//                stdout(" | value: ");
//                stdout(str);
//                stdout("\n");
                free((byte[]!) str);
                continue;
            }else => if(is_whitespace(contents[index])) {
                index = index + 1;
                while(index < length) {
                    if(is_whitespace(contents[index]) == false) {
                        break;
                    }
                    index = index + 1;
                }
//                stdout("Whitespace\n");
                continue;
            }else {
                stdout("Unknown: ");
                write(STDOUT, (byte[]!) ((ulong!) contents + start), 1);
                stdout("\n");
            }
        }
        index = index + 1;
    }

    free(contents);
    return 0;
}