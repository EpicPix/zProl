namespace zprol.compiler.lexer;

using zprol.compiler.lexer.utils;
using zprol.lang.linux.amd64;
using zprol.lang.memory;
using zprol.lang.io;
using zprol.lang;

int lex_test(String file) {
    int fd = file_open(file, O_RDONLY, 0);
    if(fd < 0) {
        return 1;
    }
    long length = file_length(fd);

    byte[] contents = malloc(length);
    file_read(fd, contents, length);
    file_close(fd);

    // no utf8 support, iterating byte by byte
    ulong index = 0;
    while(index < length) {
        ulong start = index;
        if(is_alphabet_or_underscore(contents[index])) {
            index = index + 1;
            while(index < length) {
                if(is_alphanumeric_or_underscore(contents[index]) == false) {
                    break;
                }
                index = index + 1;
            }
            byte[] byteLoc = (byte[]!) ((ulong!) contents + start);
            stdout("Word: ");
            write(STDOUT, byteLoc, index-start);
            stdout("\n");
        }else {
            if(contents[index] == 0x30) {
                if(index + 1 < length) {
                    if((contents[index + 1] | 0x20) == 0x78) {
                        index = index + 2;
                        bool validHex = true;
                        while(index < length) {
                            if(is_alphanumeric_or_underscore(contents[index]) == false) {
                                break;
                            }
                            if(is_hexadecimal(contents[index]) == false) {
                                validHex = false;
                            }
                            index = index + 1;
                        }
                        byte[] byteLoc = (byte[]!) ((ulong!) contents + start);
                        stdout("Hex: ");
                        if(validHex == false) {
                            stdout("[invalid] ");
                        }
                        write(STDOUT, byteLoc, index-start);
                        stdout("\n");
                    }else {
                        index = index + 1;
                        bool validNum = true;
                        while(index < length) {
                            if(is_alphanumeric_or_underscore(contents[index]) == false) {
                                break;
                            }
                            if(is_octal(contents[index]) == false) {
                                validNum = false;
                            }
                            index = index + 1;
                        }
                        byte[] byteLoc = (byte[]!) ((ulong!) contents + start);
                        if(index - start == 1) {
                            stdout("Zero: ");
                        }else {
                            stdout("Octal: ");
                            if(validNum == false) {
                                stdout("[invalid] ");
                            }
                        }
                        write(STDOUT, byteLoc, index-start);
                        stdout("\n");
                    }
                }
            }else => if(is_digit(contents[index])) {
                index = index + 1;
                bool validNum = true;
                while(index < length) {
                    if(is_alphanumeric_or_underscore(contents[index]) == false) {
                        break;
                    }
                    if(is_digit(contents[index]) == false) {
                        validNum = false;
                    }
                    index = index + 1;
                }
                byte[] byteLoc = (byte[]!) ((ulong!) contents + start);
                stdout("Decimal: ");
                if(validNum == false) {
                    stdout("[invalid] ");
                }
                write(STDOUT, byteLoc, index-start);
                stdout("\n");
            }
        }
        index = index + 1;
    }

    free(contents);
    return 0;
}